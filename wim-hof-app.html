<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wim Hof Breathwork</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@300;400;500;700&family=Space+Mono:wght@400;700&display=swap');

  :root {
    /* Watery/Icy Color Palette */
    --bg-deep: #051525;
    --bg-mid: #082240;
    --bg-surface: #0a2a4a;
    --ice-primary: #8fd4e6;
    --ice-light: #b8e8f5;
    --ice-bright: #d0f0fa;
    --ice-glow: rgba(143, 212, 230, 0.15);
    --frost-white: rgba(220, 240, 250, 0.85);
    --frost-dim: rgba(180, 215, 235, 0.5);
    --gold-light: #d4a84b;
    --gold-dim: rgba(212, 168, 75, 0.4);
    --glass-bg: rgba(10, 42, 74, 0.45);
    --glass-border: rgba(143, 212, 230, 0.15);
    --glass-blur: 16px;
    --transition-water: cubic-bezier(0.25, 0.1, 0.25, 1.0);
  }

  * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

  body {
    min-height: 100vh;
    background: linear-gradient(180deg, var(--bg-deep) 0%, var(--bg-mid) 50%, var(--bg-surface) 100%);
    color: var(--frost-white);
    font-family: 'DM Sans', sans-serif;
    font-weight: 400;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    overflow: hidden;
  }

  /* --- Underwater Atmosphere --- */
  .underwater-bg {
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
    overflow: hidden;
  }

  /* Caustic light patterns — sunlight through water surface */
  .caustics {
    position: absolute;
    inset: 0;
    opacity: 0.07;
    background:
      radial-gradient(ellipse 300px 200px at 20% 15%, rgba(143,212,230,0.8) 0%, transparent 70%),
      radial-gradient(ellipse 250px 350px at 75% 25%, rgba(160,232,240,0.6) 0%, transparent 70%),
      radial-gradient(ellipse 200px 150px at 50% 60%, rgba(180,220,240,0.5) 0%, transparent 70%),
      radial-gradient(ellipse 350px 250px at 30% 80%, rgba(143,212,230,0.4) 0%, transparent 70%);
    animation: causticsShift 12s ease-in-out infinite alternate;
  }
  .caustics-2 {
    position: absolute;
    inset: 0;
    opacity: 0.05;
    background:
      radial-gradient(ellipse 200px 300px at 60% 40%, rgba(176,228,245,0.7) 0%, transparent 70%),
      radial-gradient(ellipse 300px 200px at 15% 55%, rgba(143,212,230,0.5) 0%, transparent 70%),
      radial-gradient(ellipse 180px 250px at 80% 75%, rgba(160,220,240,0.6) 0%, transparent 70%);
    animation: causticsShift2 15s ease-in-out infinite alternate;
  }

  @keyframes causticsShift {
    0% { transform: translate(0, 0) scale(1); }
    50% { transform: translate(30px, -20px) scale(1.05); }
    100% { transform: translate(-20px, 15px) scale(0.95); }
  }
  @keyframes causticsShift2 {
    0% { transform: translate(0, 0) rotate(0deg) scale(1); }
    50% { transform: translate(-25px, 20px) rotate(2deg) scale(1.08); }
    100% { transform: translate(15px, -10px) rotate(-1deg) scale(0.97); }
  }

  /* Rising bubbles */
  .bubble {
    position: absolute;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, rgba(200,235,250,0.25), rgba(143,212,230,0.08));
    border: 1px solid rgba(180,225,245,0.15);
    animation: bubbleRise linear infinite;
    will-change: transform;
  }
  @keyframes bubbleRise {
    0% { transform: translateY(0) translateX(0) scale(1); opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 0.6; }
    100% { transform: translateY(-110vh) translateX(var(--drift)) scale(var(--scale-end)); opacity: 0; }
  }

  /* Vignette — depth at edges */
  .vignette {
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse 60% 60% at 50% 45%, transparent 0%, rgba(5,21,37,0.5) 100%);
  }

  .app {
    width: 100%;
    max-width: 400px;
    padding: 24px 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    justify-content: center;
    position: relative;
    z-index: 1;
  }

  .screen { display: none; width: 100%; flex-direction: column; align-items: center; }
  .screen.active { display: flex; animation: fadeIn 0.6s var(--transition-water); }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(12px); filter: blur(4px); }
    to { opacity: 1; transform: translateY(0); filter: blur(0); }
  }

  /* --- Config --- */
  .brand-sub {
    font-family: 'Space Mono', monospace; font-size: 11px; letter-spacing: 0.3em;
    text-transform: uppercase; color: rgba(143,212,230,0.45); margin-bottom: 8px;
  }
  .brand-title {
    font-size: 28px; font-weight: 300; color: var(--ice-bright); letter-spacing: 0.04em; margin-bottom: 48px;
  }

  /* Glassmorphism config card */
  #screen-config {
    background: var(--glass-bg);
    -webkit-backdrop-filter: blur(var(--glass-blur));
    backdrop-filter: blur(var(--glass-blur));
    border: 1px solid var(--glass-border);
    border-radius: 20px;
    padding: 32px 20px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.25), inset 0 1px 0 rgba(200,235,250,0.08);
  }

  .slider-group { width: 100%; margin-bottom: 28px; }
  .slider-header {
    display: flex; justify-content: space-between; margin-bottom: 8px;
    font-size: 13px; font-weight: 400; letter-spacing: 0.06em; text-transform: uppercase; color: var(--frost-dim);
  }
  .slider-val { color: var(--ice-primary); font-family: 'Space Mono', monospace; font-size: 16px; font-weight: 700; }
  .slider-track { position: relative; height: 6px; border-radius: 3px; background: rgba(143,212,230,0.08); }
  .slider-fill {
    position: absolute; top: 0; left: 0; bottom: 0; border-radius: 3px;
    background: linear-gradient(90deg, rgba(143,212,230,0.6), var(--ice-primary));
    transition: width 0.15s var(--transition-water);
  }
  .slider-track input { position: absolute; inset: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; margin: 0; }

  .btn-start {
    width: 100%; margin-top: 32px; padding: 18px 0;
    background: linear-gradient(135deg, var(--ice-primary), #5eb8cc);
    color: var(--bg-deep); border: none; border-radius: 14px;
    font-size: 15px; font-weight: 700; font-family: 'DM Sans', sans-serif; letter-spacing: 0.08em; text-transform: uppercase;
    cursor: pointer;
    box-shadow: 0 4px 24px rgba(143,212,230,0.2), inset 0 1px 0 rgba(255,255,255,0.2);
    transition: transform 0.2s var(--transition-water), box-shadow 0.2s ease;
    position: relative;
    overflow: hidden;
  }
  .btn-start::after {
    content: '';
    position: absolute; inset: 0;
    background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, transparent 50%);
    pointer-events: none;
  }
  .btn-start:active { transform: scale(0.97); box-shadow: 0 2px 12px rgba(143,212,230,0.15); }

  /* --- Session --- */
  .phase-label {
    font-family: 'Space Mono', monospace; font-size: 11px; letter-spacing: 0.25em;
    text-transform: uppercase; color: rgba(143,212,230,0.35); margin-bottom: 8px;
  }
  .round-label {
    font-family: 'Space Mono', monospace; font-size: 11px; letter-spacing: 0.15em;
    color: rgba(143,212,230,0.3); margin-bottom: 40px;
  }

  .circle-wrap {
    position: relative; width: 260px; height: 260px;
    display: flex; align-items: center; justify-content: center; margin-bottom: 32px;
  }

  /* Ripple rings around breath circle — active during breathing */
  .circle-ripple {
    position: absolute; width: 260px; height: 260px; border-radius: 50%;
    border: 1px solid rgba(143,212,230,0.1);
    opacity: 0;
    pointer-events: none;
  }
  body.phase-breathing .circle-ripple {
    animation: rippleExpand 4s var(--transition-water) infinite;
  }
  body.phase-breathing .circle-ripple:nth-child(2) { animation-delay: 1.33s; }
  body.phase-breathing .circle-ripple:nth-child(3) { animation-delay: 2.66s; }
  @keyframes rippleExpand {
    0% { transform: scale(0.85); opacity: 0.35; }
    100% { transform: scale(1.6); opacity: 0; }
  }

  .circle-glow {
    position: absolute; width: 260px; height: 260px; border-radius: 50%;
    transition: transform 0.15s linear, opacity 0.5s ease;
  }
  .circle-main {
    position: absolute; width: 220px; height: 220px; border-radius: 50%;
    border: 1.5px solid rgba(143,212,230,0.3);
    background: rgba(143,212,230,0.04);
    transition: transform 0.15s linear, background 0.5s ease, border-color 0.5s ease;
    box-shadow: 0 0 40px rgba(143,212,230,0.06), inset 0 0 30px rgba(143,212,230,0.04);
  }
  .circle-inner {
    position: absolute; width: 160px; height: 160px; border-radius: 50%;
    border: 1px solid rgba(143,212,230,0.15); opacity: 0.3;
    transition: transform 0.15s linear;
  }
  .circle-content {
    position: absolute; inset: 0;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }

  .center-big { font-family: 'Space Mono', monospace; font-size: 42px; font-weight: 700; color: var(--ice-bright); }
  .center-big.gold { color: var(--gold-light); }
  .center-big.teal { color: var(--ice-primary); }
  .center-big.countdown { font-size: 64px; color: var(--ice-light); }
  .center-sub {
    font-size: 12px; font-weight: 400; color: rgba(143,212,230,0.5);
    margin-top: 4px; letter-spacing: 0.12em; text-transform: uppercase;
  }
  .center-sub.gold { color: var(--gold-dim); }

  .guidance {
    min-height: 60px; display: flex; align-items: center; justify-content: center;
    text-align: center; padding: 0 20px;
  }
  .guidance p {
    font-size: 17px; font-weight: 400; color: rgba(200,230,245,0.8);
    line-height: 1.6; font-style: italic; letter-spacing: 0.01em;
    transition: opacity 0.4s var(--transition-water);
  }

  .btn-letgo {
    margin-top: 40px; padding: 20px 48px; min-width: 200px;
    background: rgba(212,168,75,0.08); color: var(--gold-light);
    border: 1px solid rgba(212,168,75,0.25); border-radius: 16px;
    font-size: 15px; font-weight: 700; font-family: 'DM Sans', sans-serif;
    letter-spacing: 0.08em; text-transform: uppercase;
    cursor: pointer; transition: transform 0.2s var(--transition-water);
    -webkit-backdrop-filter: blur(8px);
    backdrop-filter: blur(8px);
    box-shadow: 0 4px 20px rgba(212,168,75,0.06);
  }
  .btn-letgo:active { transform: scale(0.96); }

  .btn-abort {
    position: fixed; top: 16px; right: 16px; background: none; border: none;
    color: rgba(143,212,230,0.25); font-size: 13px; font-family: 'DM Sans', sans-serif;
    cursor: pointer; padding: 8px 12px; letter-spacing: 0.05em;
  }

  /* --- Done --- */
  #screen-done {
    background: var(--glass-bg);
    -webkit-backdrop-filter: blur(var(--glass-blur));
    backdrop-filter: blur(var(--glass-blur));
    border: 1px solid var(--glass-border);
    border-radius: 20px;
    padding: 40px 20px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.25), inset 0 1px 0 rgba(200,235,250,0.08);
  }

  .done-title { font-size: 24px; font-weight: 300; color: var(--ice-bright); margin-bottom: 48px; letter-spacing: 0.02em; }
  .result-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 14px 0; border-bottom: 1px solid rgba(143,212,230,0.06); width: 100%;
  }
  .result-label { font-size: 14px; font-weight: 400; color: var(--frost-dim); letter-spacing: 0.02em; }
  .result-time { font-family: 'Space Mono', monospace; font-size: 20px; font-weight: 700; color: var(--ice-primary); }
  .result-best { margin-top: 8px; padding-top: 18px; border-bottom: none; }
  .result-best .result-label { color: rgba(143,212,230,0.35); }
  .result-best .result-time { color: var(--ice-bright); }

  /* --- Phase-specific body classes --- */
  body.phase-retention .caustics { opacity: 0.04; }
  body.phase-retention .caustics-2 { opacity: 0.03; }
  body.phase-retention .underwater-bg {
    background: linear-gradient(180deg, rgba(5,15,30,0.3) 0%, rgba(40,30,10,0.08) 100%);
  }
  body.phase-retention .bubble { border-color: rgba(212,168,75,0.1); }

  body.phase-recovery .caustics { opacity: 0.1; }
  body.phase-recovery .caustics-2 { opacity: 0.07; }

  body.phase-done .caustics { opacity: 0.12; }
  body.phase-done .caustics-2 { opacity: 0.09; }
  body.phase-done {
    background: linear-gradient(180deg, #071e35 0%, #0a3050 50%, #0d3a55 100%);
  }
</style>
</head>
<body>

<!-- Underwater atmosphere layer -->
<div class="underwater-bg" id="underwater-bg">
  <div class="caustics"></div>
  <div class="caustics-2"></div>
  <div class="vignette"></div>
</div>

<div class="app">

  <!-- CONFIG SCREEN -->
  <div id="screen-config" class="screen active">
    <div class="brand-sub">Wim Hof Methode</div>
    <div class="brand-title">Breathwork</div>

    <div class="slider-group">
      <div class="slider-header"><span>Runden</span><span class="slider-val" id="val-rounds">3</span></div>
      <div class="slider-track"><div class="slider-fill" id="fill-rounds"></div><input type="range" id="sl-rounds" min="1" max="6" value="3"></div>
    </div>
    <div class="slider-group">
      <div class="slider-header"><span>Atemzüge</span><span class="slider-val" id="val-breaths">30</span></div>
      <div class="slider-track"><div class="slider-fill" id="fill-breaths"></div><input type="range" id="sl-breaths" min="20" max="50" value="30"></div>
    </div>
    <div class="slider-group">
      <div class="slider-header"><span>Retention (Sek.)</span><span class="slider-val" id="val-retention">90s</span></div>
      <div class="slider-track"><div class="slider-fill" id="fill-retention"></div><input type="range" id="sl-retention" min="30" max="300" value="90"></div>
    </div>
    <div class="slider-group">
      <div class="slider-header"><span>Recovery (Sek.)</span><span class="slider-val" id="val-recovery">15s</span></div>
      <div class="slider-track"><div class="slider-fill" id="fill-recovery"></div><input type="range" id="sl-recovery" min="10" max="30" value="15"></div>
    </div>

    <div class="slider-group">
      <div class="slider-header"><span>Atemtempo (Sek.)</span><span class="slider-val" id="val-tempo">4s</span></div>
      <div class="slider-track"><div class="slider-fill" id="fill-tempo"></div><input type="range" id="sl-tempo" min="2" max="8" value="4"></div>
    </div>

    <div class="slider-group">
      <div class="slider-header"><span>Audio</span><span class="slider-val" id="val-audio">An</span></div>
      <div class="slider-track"><div class="slider-fill" id="fill-audio"></div><input type="range" id="sl-audio" min="0" max="1" value="1"></div>
    </div>
    <div class="slider-group" id="grp-volume">
      <div class="slider-header"><span>Lautstärke</span><span class="slider-val" id="val-volume">70%</span></div>
      <div class="slider-track"><div class="slider-fill" id="fill-volume"></div><input type="range" id="sl-volume" min="0" max="100" value="70"></div>
    </div>

    <button class="btn-start" id="btn-start">Session starten</button>
  </div>

  <!-- SESSION SCREEN -->
  <div id="screen-session" class="screen">
    <div class="phase-label" id="phase-label"></div>
    <div class="round-label" id="round-label"></div>

    <div class="circle-wrap">
      <div class="circle-ripple"></div>
      <div class="circle-ripple"></div>
      <div class="circle-ripple"></div>
      <div class="circle-glow" id="circle-glow"></div>
      <div class="circle-main" id="circle-main"></div>
      <div class="circle-inner" id="circle-inner"></div>
      <div class="circle-content" id="circle-content"></div>
    </div>

    <div class="guidance"><p id="guidance-text"></p></div>

    <div id="action-area"></div>
    <button class="btn-abort" id="btn-abort">✕ Beenden</button>
  </div>

  <!-- DONE SCREEN -->
  <div id="screen-done" class="screen">
    <div class="brand-sub">Session beendet</div>
    <div class="done-title">Gut gemacht.</div>
    <div id="results-list" style="width:100%; margin-bottom: 48px;"></div>
    <button class="btn-start" id="btn-restart">Neue Session</button>
  </div>

</div>

<script>
(function() {
  // --- State ---
  const config = { rounds: 3, breaths: 30, retentionMax: 90, recoveryDuration: 15, breathCycle: 4, audioEnabled: 1, audioVolume: 70 };
  let currentRound = 0;
  let retentionTimes = [];
  let animFrame = null;
  let timerInterval = null;
  let wakeLock = null;

  // --- DOM ---
  const $ = (id) => document.getElementById(id);
  const screens = { config: $('screen-config'), session: $('screen-session'), done: $('screen-done') };

  function showScreen(name) {
    Object.values(screens).forEach(s => s.classList.remove('active'));
    screens[name].classList.add('active');
  }

  // --- Phase body class management ---
  function setPhaseClass(phase) {
    document.body.classList.remove('phase-breathing', 'phase-retention', 'phase-recovery', 'phase-done');
    if (phase) document.body.classList.add('phase-' + phase);
  }

  // --- Bubble particles ---
  const bubbleContainer = $('underwater-bg');
  let bubbleInterval = null;

  function createBubble() {
    const el = document.createElement('div');
    el.className = 'bubble';
    const size = 4 + Math.random() * 12;
    const left = 10 + Math.random() * 80;
    const duration = 12 + Math.random() * 18;
    const drift = (Math.random() - 0.5) * 40;
    const scaleEnd = 0.6 + Math.random() * 0.5;
    el.style.cssText = 'width:' + size + 'px;height:' + size + 'px;left:' + left + '%;bottom:-20px;' +
      'animation-duration:' + duration + 's;--drift:' + drift + 'px;--scale-end:' + scaleEnd + ';';
    bubbleContainer.appendChild(el);
    setTimeout(() => el.remove(), duration * 1000);
  }

  function startBubbles() {
    if (bubbleInterval) return;
    bubbleInterval = setInterval(createBubble, 2500);
    // Seed a few initial bubbles
    for (let i = 0; i < 4; i++) setTimeout(createBubble, i * 600);
  }

  function stopBubbles() {
    if (bubbleInterval) { clearInterval(bubbleInterval); bubbleInterval = null; }
  }

  // Start bubbles on load
  startBubbles();

  // --- Sliders ---
  const sliders = [
    { id: 'rounds', key: 'rounds', suffix: '' },
    { id: 'breaths', key: 'breaths', suffix: '' },
    { id: 'retention', key: 'retentionMax', suffix: 's' },
    { id: 'recovery', key: 'recoveryDuration', suffix: 's' },
    { id: 'tempo', key: 'breathCycle', suffix: 's' },
    { id: 'audio', key: 'audioEnabled', suffix: '', format: v => v ? 'An' : 'Aus' },
    { id: 'volume', key: 'audioVolume', suffix: '%' },
  ];

  sliders.forEach(({ id, key, suffix, format }) => {
    const sl = $('sl-' + id);
    const val = $('val-' + id);
    const fill = $('fill-' + id);

    function update() {
      const v = parseInt(sl.value);
      config[key] = v;
      val.textContent = format ? format(v) : v + suffix;
      const pct = ((v - sl.min) / (sl.max - sl.min)) * 100;
      fill.style.width = pct + '%';
    }

    sl.addEventListener('input', update);
    update();
  });

  // --- Format ---
  function fmt(sec) {
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return m > 0 ? m + ':' + String(s).padStart(2, '0') : String(s);
  }

  // --- Circle ---
  function setCircle(scale, glowColor, borderColor, bgColor) {
    const glow = $('circle-glow');
    const main = $('circle-main');
    const inner = $('circle-inner');
    glow.style.transform = 'scale(' + (scale * 1.3) + ')';
    glow.style.background = 'radial-gradient(circle, ' + glowColor + ' 0%, transparent 70%)';
    main.style.transform = 'scale(' + scale + ')';
    main.style.borderColor = borderColor;
    main.style.background = bgColor;
    inner.style.transform = 'scale(' + (scale * 0.95) + ')';
    inner.style.borderColor = borderColor;
  }

  function setCircleInstant() {
    const glow = $('circle-glow');
    const main = $('circle-main');
    const inner = $('circle-inner');
    [glow, main, inner].forEach(el => { el.style.transition = 'none'; });
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        [glow, main, inner].forEach(el => { el.style.transition = ''; });
      });
    });
  }

  function setContent(html) { $('circle-content').innerHTML = html; }
  function setGuidance(text) { $('guidance-text').textContent = text; }
  function setPhaseLabel(text) { $('phase-label').textContent = text; }
  function setRoundLabel(r, total) { $('round-label').textContent = 'Runde ' + r + ' / ' + total; }

  // --- Wake Lock ---
  async function requestWake() {
    try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch {}
  }
  function releaseWake() {
    if (wakeLock) { wakeLock.release(); wakeLock = null; }
  }

  // --- Vibration ---
  function vibrate(pattern) {
    if ('vibrate' in navigator) navigator.vibrate(pattern);
  }

  // --- Fullscreen ---
  function requestFullscreen() {
    const el = document.documentElement;
    const rfs = el.requestFullscreen || el.webkitRequestFullscreen;
    if (rfs) rfs.call(el).catch(() => {});
  }
  function exitFullscreen() {
    if (document.fullscreenElement || document.webkitFullscreenElement) {
      (document.exitFullscreen || document.webkitExitFullscreen).call(document).catch(() => {});
    }
  }

  // --- Easing ---
  function easeInOutSine(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
  }

  // --- Audio Engine (Hybrid: MP3 → Advanced Synthesis Fallback) ---
  const audio = {
    ctx: null,
    bufferCache: new Map(),
    ambientSource: null,
    ambientGain: null,
    ambientNodes: [],

    SNIPPETS: [
      'session_start', 'session_end', 'guide_01', 'guide_02', 'guide_03',
      'motiv_01', 'motiv_02', 'motiv_03', 'motiv_04',
      'breath_cue', 'recovery_end', 'round_done', 'ambient'
    ],

    // Synthesis config: method + parameters per snippet
    SYNTH: {
      session_start: { method: 'singingBowl', freq: 220, dur: 4.0 },
      session_end:   { method: 'singingBowl', freq: 196, dur: 5.0 },
      guide_01:      { method: 'chime', freq: 880, dur: 2.0 },
      guide_02:      { method: 'chime', freq: 784, dur: 2.0 },
      guide_03:      { method: 'chime', freq: 659, dur: 2.5 },
      motiv_01:      { method: 'warmTone', freq: 330, dur: 1.5 },
      motiv_02:      { method: 'warmTone', freq: 370, dur: 1.5 },
      motiv_03:      { method: 'warmTone', freq: 392, dur: 1.5 },
      motiv_04:      { method: 'warmTone', freq: 440, dur: 1.5 },
      breath_cue:    { method: 'breathCue', dur: 0.15 },
      recovery_end:  { method: 'singingBowl', freq: 262, dur: 3.5 },
      round_done:    { method: 'chime', freq: 740, dur: 2.5 },
    },

    init() {
      if (this.ctx) { this.ctx.resume(); return; }
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    },

    async loadAll() {
      for (const name of this.SNIPPETS) {
        try {
          const res = await fetch('audio/' + name + '.mp3');
          if (!res.ok) continue;
          const buf = await res.arrayBuffer();
          this.bufferCache.set(name, await this.ctx.decodeAudioData(buf));
        } catch (e) { /* synthesis fallback used */ }
      }
    },

    play(name) {
      if (!config.audioEnabled || !this.ctx) return;
      const vol = config.audioVolume / 100;
      const buf = this.bufferCache.get(name);
      if (buf) {
        const src = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        gain.gain.value = vol;
        src.buffer = buf;
        src.connect(gain).connect(this.ctx.destination);
        src.start();
        return;
      }
      const s = this.SYNTH[name];
      if (!s) return;
      switch (s.method) {
        case 'singingBowl': this.playSingingBowl(s.freq, s.dur, vol); break;
        case 'chime':       this.playChime(s.freq, s.dur, vol); break;
        case 'warmTone':    this.playWarmTone(s.freq, s.dur, vol); break;
        case 'breathCue':   this.playBreathCue(s.dur, vol); break;
      }
    },

    // Tibetan singing bowl: layered inharmonic partials with beating
    playSingingBowl(freq, dur, vol) {
      const t = this.ctx.currentTime;
      const partials = [
        { ratio: 1.0,  amp: 1.0,  decay: dur },
        { ratio: 2.71, amp: 0.35, decay: dur * 0.75 },
        { ratio: 4.58, amp: 0.15, decay: dur * 0.55 },
        { ratio: 6.17, amp: 0.08, decay: dur * 0.4 },
      ];
      partials.forEach(p => {
        const f = freq * p.ratio;
        const a = vol * 0.25 * p.amp;
        // Main partial
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = f;
        gain.gain.setValueAtTime(a, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + p.decay);
        osc.connect(gain).connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + p.decay + 0.05);
        // Beating pair (detuned ~0.8Hz)
        const osc2 = this.ctx.createOscillator();
        const gain2 = this.ctx.createGain();
        osc2.type = 'sine';
        osc2.frequency.value = f + 0.8;
        gain2.gain.setValueAtTime(a * 0.5, t);
        gain2.gain.exponentialRampToValueAtTime(0.001, t + p.decay);
        osc2.connect(gain2).connect(this.ctx.destination);
        osc2.start(t);
        osc2.stop(t + p.decay + 0.05);
      });
    },

    // FM synthesis bell/chime: carrier + modulator at inharmonic ratio
    playChime(freq, dur, vol) {
      const t = this.ctx.currentTime;
      // Modulator (inharmonic ratio → metallic timbre)
      const mod = this.ctx.createOscillator();
      const modGain = this.ctx.createGain();
      mod.type = 'sine';
      mod.frequency.value = freq * 3.5;
      modGain.gain.setValueAtTime(freq * 0.7, t);
      modGain.gain.exponentialRampToValueAtTime(1, t + dur);
      // Carrier
      const carrier = this.ctx.createOscillator();
      const cGain = this.ctx.createGain();
      carrier.type = 'sine';
      carrier.frequency.value = freq;
      cGain.gain.setValueAtTime(vol * 0.3, t);
      cGain.gain.exponentialRampToValueAtTime(0.001, t + dur);
      // FM routing: modulator → carrier.frequency
      mod.connect(modGain).connect(carrier.frequency);
      carrier.connect(cGain).connect(this.ctx.destination);
      mod.start(t);
      carrier.start(t);
      mod.stop(t + dur + 0.05);
      carrier.stop(t + dur + 0.05);
    },

    // Warm triangle wave with gentle attack + octave shimmer
    playWarmTone(freq, dur, vol) {
      const t = this.ctx.currentTime;
      // Root (triangle = warmer harmonics than sine)
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = 'triangle';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.001, t);
      gain.gain.linearRampToValueAtTime(vol * 0.25, t + 0.08);
      gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
      osc.connect(gain).connect(this.ctx.destination);
      osc.start(t);
      osc.stop(t + dur + 0.05);
      // Octave shimmer (sine, quieter, shorter decay)
      const osc2 = this.ctx.createOscillator();
      const gain2 = this.ctx.createGain();
      osc2.type = 'sine';
      osc2.frequency.value = freq * 2;
      gain2.gain.setValueAtTime(0.001, t);
      gain2.gain.linearRampToValueAtTime(vol * 0.06, t + 0.08);
      gain2.gain.exponentialRampToValueAtTime(0.001, t + dur * 0.6);
      osc2.connect(gain2).connect(this.ctx.destination);
      osc2.start(t);
      osc2.stop(t + dur * 0.6 + 0.05);
    },

    // Filtered noise burst: soft "tsh" instead of harsh beep
    playBreathCue(dur, vol) {
      const ctx = this.ctx;
      const t = ctx.currentTime;
      const len = Math.ceil(ctx.sampleRate * dur);
      const noiseBuf = ctx.createBuffer(1, len, ctx.sampleRate);
      const data = noiseBuf.getChannelData(0);
      for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
      const src = ctx.createBufferSource();
      src.buffer = noiseBuf;
      const filter = ctx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 2500;
      filter.Q.value = 1.2;
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(vol * 0.2, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
      src.connect(filter).connect(gain).connect(ctx.destination);
      src.start(t);
    },

    startAmbient() {
      if (!config.audioEnabled || !this.ctx || this.ambientSource) return;
      const vol = config.audioVolume / 100;
      const buf = this.bufferCache.get('ambient');
      if (buf) {
        this.ambientSource = this.ctx.createBufferSource();
        this.ambientGain = this.ctx.createGain();
        this.ambientGain.gain.value = vol * 0.15;
        this.ambientSource.buffer = buf;
        this.ambientSource.loop = true;
        this.ambientSource.connect(this.ambientGain).connect(this.ctx.destination);
        this.ambientSource.start();
        return;
      }
      // Ocean-like ambient: filtered noise with LFO wave rhythm
      const ctx = this.ctx;
      const bufSize = ctx.sampleRate * 4;
      const noiseBuf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
      const data = noiseBuf.getChannelData(0);
      for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
      const src = ctx.createBufferSource();
      src.buffer = noiseBuf;
      src.loop = true;
      // Low-pass filter for deep ocean character
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 400;
      filter.Q.value = 0.7;
      // LFO for wave rhythm (~7s cycle)
      const lfo = ctx.createOscillator();
      const lfoGain = ctx.createGain();
      lfo.type = 'sine';
      lfo.frequency.value = 0.14;
      lfoGain.gain.value = vol * 0.04;
      // Master gain
      const masterGain = ctx.createGain();
      masterGain.gain.value = vol * 0.08;
      // Routing
      lfo.connect(lfoGain).connect(masterGain.gain);
      src.connect(filter).connect(masterGain).connect(ctx.destination);
      src.start();
      lfo.start();
      this.ambientSource = src;
      this.ambientGain = masterGain;
      this.ambientNodes = [src, lfo];
    },

    stopAmbient() {
      if (!this.ambientSource || !this.ctx) return;
      if (this.ambientGain) {
        this.ambientGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.3);
      }
      const nodes = [this.ambientSource, ...this.ambientNodes];
      setTimeout(() => {
        nodes.forEach(n => { try { n.stop(); } catch(e) {} });
      }, 500);
      this.ambientSource = null;
      this.ambientGain = null;
      this.ambientNodes = [];
    },

    stopAll() {
      this.stopAmbient();
      if (this.ctx) { this.ctx.close().catch(() => {}); this.ctx = null; }
      this.bufferCache.clear();
    }
  };

  // --- Session Flow ---
  function startSession() {
    currentRound = 1;
    retentionTimes = [];
    requestWake();
    requestFullscreen();
    showScreen('session');
    $('btn-abort').style.display = 'block';
    if (config.audioEnabled) {
      audio.init();
      audio.loadAll();
      audio.play('session_start');
      audio.startAmbient();
    }
    runCountdown();
  }

  function endSession() {
    cancelAnimationFrame(animFrame);
    clearInterval(timerInterval);
    audio.stopAll();
    releaseWake();
    exitFullscreen();
    setPhaseClass(null);
    $('btn-abort').style.display = 'none';
    showScreen('config');
  }

  // --- Countdown ---
  function runCountdown() {
    vibrate(100);
    setPhaseClass('breathing');
    let count = 3;
    $('action-area').innerHTML = '';
    setPhaseLabel('Bereit machen');
    setRoundLabel(currentRound, config.rounds);
    setCircle(0.7, 'rgba(143,212,230,0.06)', 'rgba(143,212,230,0.25)', 'rgba(143,212,230,0.04)');
    setContent('<span class="center-big countdown">' + count + '</span>');
    setGuidance('');

    timerInterval = setInterval(() => {
      count--;
      if (count <= 0) {
        clearInterval(timerInterval);
        runBreathing();
        return;
      }
      setContent('<span class="center-big countdown">' + count + '</span>');
    }, 1000);
  }

  // --- Breathing ---
  function runBreathing() {
    const CYCLE = config.breathCycle * 1000;
    const total = config.breaths;
    let start = performance.now();
    let guidanceState = 0;
    let lastBreathPlayed = -1;

    setPhaseLabel('Phase 1 · Atmen');
    setGuidance('Atme tief ein… und lass los.');
    $('action-area').innerHTML = '';
    audio.play('guide_01');

    function animate() {
      const elapsed = performance.now() - start;
      const completed = Math.floor(elapsed / CYCLE);

      if (completed >= total) {
        cancelAnimationFrame(animFrame);
        runRetention();
        return;
      }

      if (completed !== lastBreathPlayed) {
        lastBreathPlayed = completed;
        audio.play('breath_cue');
      }

      const cyclePos = (elapsed % CYCLE) / CYCLE;
      const inhaling = cyclePos <= 0.5;
      const t = inhaling ? cyclePos / 0.5 : (cyclePos - 0.5) / 0.5;
      const e = easeInOutSine(t);
      const scale = inhaling ? 0.55 + e * 0.45 : 1.0 - e * 0.45;
      const op = inhaling ? 0.4 + e * 0.5 : 0.9 - e * 0.5;

      setCircleInstant();
      setCircle(
        scale,
        'rgba(143,212,230,' + (0.04 + op * 0.08) + ')',
        'rgba(143,212,230,' + (0.2 + op * 0.35) + ')',
        'rgba(143,212,230,' + (0.03 + op * 0.1) + ')'
      );

      const label = inhaling ? 'Einatmen' : 'Ausatmen';
      setContent('<span class="center-big teal">' + (completed + 1) + '</span><span class="center-sub">' + label + '</span>');

      if (guidanceState === 0 && completed >= Math.floor(total / 2)) {
        guidanceState = 1;
        setGuidance('Weiter. Tief ein… locker aus.');
      }
      if (guidanceState === 1 && completed >= total - 2) {
        guidanceState = 2;
        audio.play('guide_02');
        setGuidance('Letzter Atemzug. Atme aus… und halte.');
      }

      animFrame = requestAnimationFrame(animate);
    }

    animFrame = requestAnimationFrame(animate);
  }

  // --- Retention ---
  function runRetention() {
    vibrate([100, 50, 200]);
    setPhaseClass('retention');
    let startTime = Date.now();
    let motivIdx = 0;
    const motivations = ['Entspanne deinen Körper.', 'Du machst das gut.', 'Bleib ruhig. Lass los.', 'Gib nicht auf.'];

    setPhaseLabel('Phase 2 · Halten');
    setGuidance('Halte. Entspanne deinen Körper.');
    setCircle(0.5, 'rgba(212,168,75,0.05)', 'rgba(212,168,75,0.25)', 'rgba(212,168,75,0.04)');

    $('action-area').innerHTML = '<button class="btn-letgo" id="btn-letgo">Loslassen</button>';
    $('btn-letgo').addEventListener('click', abortRetention);

    function abortRetention() {
      vibrate(150);
      audio.play('guide_03');
      clearInterval(timerInterval);
      const secs = Math.floor((Date.now() - startTime) / 1000);
      retentionTimes.push(secs);
      setGuidance('Okay. Atme tief ein.');
      $('action-area').innerHTML = '';
      setTimeout(runRecovery, 1200);
    }

    timerInterval = setInterval(() => {
      const secs = Math.floor((Date.now() - startTime) / 1000);
      setContent('<span class="center-big gold">' + fmt(secs) + '</span><span class="center-sub gold">/ ' + fmt(config.retentionMax) + '</span>');

      // Pulse border
      const pulse = 0.2 + Math.sin(Date.now() / 1500) * 0.12;
      $('circle-main').style.borderColor = 'rgba(212,168,75,' + pulse + ')';
      $('circle-inner').style.borderColor = 'rgba(212,168,75,' + pulse + ')';
      $('circle-main').style.boxShadow = '0 0 ' + (30 + pulse * 20) + 'px rgba(212,168,75,' + (pulse * 0.12) + '), inset 0 0 20px rgba(212,168,75,' + (pulse * 0.06) + ')';

      // Motivation
      if (secs > 10 && secs % 20 === 0 && motivIdx < motivations.length) {
        audio.play('motiv_0' + (motivIdx + 1));
        setGuidance(motivations[motivIdx]);
        motivIdx++;
      }

      if (secs >= config.retentionMax) {
        clearInterval(timerInterval);
        audio.play('guide_03');
        retentionTimes.push(secs);
        setGuidance('Zeit. Atme jetzt tief ein.');
        $('action-area').innerHTML = '';
        setTimeout(runRecovery, 1500);
      }
    }, 250);
  }

  // --- Recovery ---
  function runRecovery() {
    vibrate(200);
    setPhaseClass('recovery');
    const duration = config.recoveryDuration;
    let startTime = Date.now();

    setPhaseLabel('Phase 3 · Recovery');
    setGuidance('Tief einatmen… und halten.');
    setCircle(0.95, 'rgba(143,212,230,0.08)', 'rgba(143,212,230,0.45)', 'rgba(143,212,230,0.08)');
    $('circle-main').style.boxShadow = '0 0 40px rgba(143,212,230,0.08), inset 0 0 30px rgba(143,212,230,0.05)';
    $('action-area').innerHTML = '';

    timerInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const remaining = Math.max(0, duration - elapsed);
      setContent('<span class="center-big teal">' + fmt(remaining) + '</span><span class="center-sub">Recovery</span>');

      if (elapsed >= duration) {
        clearInterval(timerInterval);
        audio.play('recovery_end');
        setGuidance('Langsam ausatmen.');

        setTimeout(() => {
          if (currentRound < config.rounds) {
            audio.play('round_done');
            setGuidance('Gut gemacht. Nächste Runde.');
            setTimeout(() => {
              currentRound++;
              runCountdown();
            }, 2500);
          } else {
            showDone();
          }
        }, 1500);
      }
    }, 250);
  }

  // --- Done ---
  function showDone() {
    vibrate([100, 50, 100, 50, 300]);
    setPhaseClass('done');
    audio.play('session_end');
    audio.stopAmbient();
    releaseWake();
    exitFullscreen();
    showScreen('done');

    let html = '';
    retentionTimes.forEach((t, i) => {
      html += '<div class="result-row"><span class="result-label">Runde ' + (i + 1) + '</span><span class="result-time">' + fmt(t) + '</span></div>';
    });

    if (retentionTimes.length > 1) {
      const best = Math.max(...retentionTimes);
      html += '<div class="result-row result-best"><span class="result-label">Längste</span><span class="result-time" style="color:#e4f0f6">' + fmt(best) + '</span></div>';
    }

    $('results-list').innerHTML = html;
  }

  // --- Events ---
  $('btn-start').addEventListener('click', startSession);
  $('btn-abort').addEventListener('click', endSession);
  $('btn-restart').addEventListener('click', () => { setPhaseClass(null); showScreen('config'); });

})();
</script>

</body>
</html>
